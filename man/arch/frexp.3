.\" @(#)frexp.3 1.1 92/07/30 SMI; from UCB 4.2
.TH FREXP 3 "16 September 1986"
.SH NAME
frexp, ldexp, modf \- floating point analysis and synthesis
.SH SYNOPSIS
.nf
.B double frexp(value, eptr)
.B double value;
.B int *eptr;
.PP
.B double ldexp(value, exp)
.B double value;
.B int exp;
.PP
.B double modf(value, iptr)
.B double value, *iptr;
.IX  "frexp function"  ""  "\fLfrexp\fP \(em split into mantissa and exponent"
.IX  "ldexp function"  ""  "\fLldexp\fP \(em split into mantissa and exponent"
.IX  "modf function"  ""  "\fLmodf\fP \(em split into mantissa and exponent"
.IX  "split into mantissa and exponent \(em \fLfrexp\fR"
.IX  "mantissa and exponent, split into \(em \fLfrexp\fR"
.IX  "exponent and mantissa, split into \(em \fLfrexp\fR"
.SH DESCRIPTION
.I Frexp
returns the significand of a double 
.I value
as a double quantity,
.I x,
of magnitude less than 1
and stores an integer 
.I n,
indirectly through 
.I eptr,
such that
.I value
=
\fIx\fP\|\(**\|2\u\fIn\fP\d.
.LP
The results are not defined when 
.I value 
is an IEEE infinity or NaN.
.LP
.I ldexp
returns the quantity:
.IP
\fIvalue\|*\|2\u\fIexp\fP\d.
.PP
.I modf
returns the fractional part of
.I value
and stores the integral part indirectly
through 
.I iptr.
Thus the argument 
.I value
and the returned values
.I modf
and
.I *iptr
satisfy, in the absence of rounding error,
.IP
(*\fIiptr\fP + \fImodf\fP) == \fIvalue\fP
.LP
and
.IP
0 <= \fIabs\fP(\fImodf\fP) < \fIabs\fP(\fIvalue\fP).
.LP
The signs of 
*\fIiptr\fP and \fImodf\fP
are the same as the signs of 
.I value.
The results are not defined when 
.I value 
is an IEEE infinity or NaN.
.PP
Since Sun's definition of 
.I modf
conforms to the System V Interface Definition
and the VAX 4.2BSD implementation 
but differs from the 4.2BSD documentation,
results vary from some other Unix implementations whose
.I modf
conforms to the 4.2BSD documentation but not the 
VAX 4.2BSD implementation. 
Therefore avoid 
.I modf 
in code intended to be portable.
.SH SEE ALSO
floor(3m)
