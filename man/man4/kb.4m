.\" @(#)kb.4m 1.1 92/07/30 SMI
.TH KB 4M "30 November 1989"
.SH NAME
kb \- Sun keyboard STREAMS module
.SH CONFIG
.BI "pseudo-device kb" number
.SH SYNOPSIS
.nf
.ft B
#include <sys/types.h>
#include <sys/stream.h>
#include <sys/stropts.h>
#include <sundev/vuid_event.h>
#include <sundev/kbio.h>
#include <sundev/kbd.h>
.LP
.ft B
ioctl(fd, \s-1I_PUSH\s0, "kb");
.ft R
.fi
.SH DESCRIPTION
.IX  "kb streams module"  ""  "\fLkb\fP \(em Sun keyboard \s-1STREAMS\s0 module"
.LP
The
.B kb
.SM STREAMS
module processes byte streams
generated by Sun keyboards attached to a
.SM CPU
serial or parallel port.
Definitions for altering keyboard translation, and reading events
from the keyboard, are in
.B <sundev/kbio.h>
and
.BR <sundev/kbd.h> .
.I number
specifies the maximum number of
keyboards supported by the system.
.LP
.B kb
recognizes which keys have been typed using a set of
tables for each known type of keyboard.
Each translation table is
an array of 128 16-bit words
.RB ( "unsigned short" s).
If an entry in the table is less than 0x100, it is treated as an
.SM ISO
8859/1 character.
Higher values indicate special characters that invoke
more complicated actions.
.SS Keyboard Translation Mode
.LP
The keyboard can be in one of the following translation modes:
.LP
.RS
.TP 25
.SB TR_NONE
Keyboard translation is turned off and
up/down key codes are reported.
.TP
.SB TR_ASCII
.SM ISO
8859/1 codes are reported.
.TP
.SB TR_EVENT
.B firm_events
are reported
(see
.TX SVPG ).
.TP
.SB TR_UNTRANS_EVENT
.B firm_events
containing unencoded keystation codes are reported
for all input events within the window system.
.RE
.SS Keyboard Translation-Table Entries
.LP
All instances of the
.B kb
module share seven translation tables used to convert raw keystation codes to
event values.
The tables are:
.LP
.RS
.TP 20
Unshifted
Used when a key is depressed and no shifts are in effect.
.TP
Shifted
Used when a key is depressed and a Shift key is being held down.
.TP
Caps Lock
Used when a key is depressed and Caps Lock is in effect.
.TP
Alt Graph
Used when a key is depressed and the Alt Graph key is being held down.
.TP
Num Lock
Used when a key is depressed and Num Lock is in effect.
.TP
Controlled
Used when a key is depressed and the Control key is being held down (regardless
of whether a Shift key or the Alt Graph is being held down, or whether Caps
Lock or Num Lock is in effect).
.TP
Key Up
Used when a key is released.
.RE
.LP
Each key on the keyboard has a \*(lqkey station\*(rq code which is a number from 0 to
127.
This number is used as an index into the translation table that is
currently in effect.
If the corresponding entry in that translation table
is a value from 0 to 255, this value is treated as an
.SM ISO
8859/1 character, and that character is the result of the translation.
.LP
If the entry is a value above 255, it is a \*(lqspecial\*(rq entry.
Special entry values are classified according to the value of
the high-order bits.
The high-order value for each class is
defined as a constant, as shown in the list below.
The value of the low-order bits, when added to this constant, distinguishes
between keys within each class:
.TP 20
.SM SHIFTKEYS\s0 0x100
A shift key.
The value of the particular shift
key is added to determine which shift mask to apply:
.RS
.TP 20
.SM CAPSLOCK\s0 0
\*(lqCaps Lock\*(rq key.
.TP
.SM SHIFTLOCK\s0 1
\*(lqShift Lock\*(rq key.
.TP
.SM LEFTSHIFT\s0 2
Left-hand \*(lqShift\*(rq key.
.TP
.SM RIGHTSHIFT\s0 3
Right-hand \*(lqShift\*(rq key.
.TP
.SM LEFTCTRL\s0 4
Left-hand (or only) \*(lqControl\*(rq key.
.TP
.SM RIGHTCTRL\s0 5
Right-hand \*(lqControl\*(rq key.
.TP
.SM ALTGRAPH\s0 9
\*(lqAlt Graph\*(rq key.
.TP
.SM ALT\s0 10
\*(lqAlternate\*(rq key on the Sun-3 keyboard, or \*(lqAlt\*(rq key on the Sun-4
keyboard.
.TP
.SM NUMLOCK\s0 11
\*(lqNum Lock\*(rq key.
.RE
.TP
.SM BUCKYBITS\s0 0x200
Used to toggle mode-key-up/down status without altering the value of
an accompanying
.SM ISO
8859/1 character.
The actual bit-position value, minus 7, is added.
.RS
.TP 20
.SM METABIT\s0 0
The \*(lqMeta\*(rq key was pressed along with the key.
This is the only
user-accessible bucky bit.
It is ORed in as the 0x80 bit; since this bit is a
legitimate bit in a character, the only way to distinguish between, for
example, 0xA0 as 
.SM META\s0+0x20
and 0xA0 as an 8-bit character is to watch for
\*(lq\s-1META\s0 key up\*(rq and
\*(lq\s-1META\s0 key down\*(rq events and keep track of whether the
.SM META
key was down.
.TP
.SM SYSTEMBIT\s0 1
The \*(lqSystem\*(rq key was pressed.
This is a place holder to indicate
which key is the system-abort key.
.RE
.TP
.SM FUNNY\s0 0x300
Performs various functions depending on the value of the low 4
bits:
.RS
.TP 20
.SM NOP\s0 0x300
Does nothing.
.TP
.SM OOPS\s0 0x301
Exists, but is undefined.
.TP
.SM HOLE\s0 0x302
There is no key in this position on the keyboard, and
the position-code should not be used.
.TP
.SM NOSCROLL\s0 0x303
Alternately sends
.SM CTRL\s0-S
and
.SM CTRL\s0-Q
characters.
.TP
.SM CTRLS\s0 0x304
Sends 
.SM CTRL\s0-S
character and toggles
.SM NOSCROLL\s0
key.
.TP
.SM CTRLQ\s0 0x305
Sends 
.SM CTRL\s0-Q
character and toggles
.SM NOSCROLL
key.
.TP
.SM RESET\s0 0x306
Keyboard reset.
.TP
.SM ERROR\s0 0x307
The keyboard driver detected an internal error.
.TP
.SM IDLE\s0 0x308
The keyboard is idle (no keys down).
.TP
.SM COMPOSE\s0 0x309
This key is the
.SM COMPOSE
key; the next two keys should comprise a two-character \*(lq\s-1COMPOSE\s0 key\*(rq
sequence.
.br
.ne 9
.TP
.SM NONL\s0 0x30A
Used only in the Num Lock table; indicates that this key is not affected by the
Num Lock state, so that the translation table to use to translate this key
should be the one that would have been used had Num Lock not been in effect.
.TP
0x30B \(em 0x30F
Reserved for nonparameterized functions.
.RE
.TP
.SM FA_CLASS\s0 0x400
This key is a \*(lqfloating accent\*(rq or \*(lqdead\*(rq key.
When this key is pressed,
the next key generates an event for an accented character; for example,
\*(lqfloating accent grave\*(rq followed by the \*(lqa\*(rq key generates an event with the
.SM ISO
8859/1 code for the \*(lqa with grave accent\*(rq character.
The low-order bits indicate which accent; the codes for the individual
\*(lqfloating accents\*(rq are as follows:
.RS
.TP 20
.SM FA_UMLAUT\s0 0x400
umlaut
.TP 20
.SM FA_CFLEX\s0 0x401
circumflex
.TP 20
.SM FA_TILDE\s0 0x402
tilde
.TP 20
.SM FA_CEDILLA\s0 0x403
cedilla
.TP 20
.SM FA_ACUTE\s0 0x404
acute accent
.TP 20
.SM FA_GRAVE\s0 0x405
grave accent
.RE
.TP
.SM STRING\s0 0x500
The low-order bits index a table of strings.
When a key with a
.SB STRING
entry is depressed, the characters in the null-terminated string
for that key are sent, character by character.
The maximum length
is defined as:
.RS
.IP
.SM KTAB_STRLEN\s0 10
.LP
Individual string numbers are defined as:
.RS
.TP 15
.PD 0
.SM HOMEARROW
0x00
.TP
.SM UPARROW
0x01
.TP
.SM DOWNARROW
0x02
.TP
.SM LEFTARROW
0x03
.TP
.SM RIGHTARROW
0x04
.PD
.RE
.LP
String numbers 0x05 \(em 0x0F are available for custom entries.
.RE
.br
.ne 5
.TP
.SM FUNCKEYS\s0 0x600
Function keys.
The next-to-lowest 4 bits indicate the group of function keys:
.RS
.RS
.TP
.SM LEFTFUNC\s0 0x600
.PD 0
.TP
.SM RIGHTFUNC\s0 0x610
.TP
.SM TOPFUNC\s0 0x620
.TP
.SM BOTTOMFUNC\s0 0x630
.RE
.RE
.PD
.LP
The low 4 bits indicate the function key number within the group:
.PD
.RS
.TP 20
.RI \s-1LF\s0( n )
.RI (\s-1LEFTFUNC\s0+( n )-1)
.PD 0
.TP
.RI \s-1RF\s0( n )
.RI (\s-1RIGHTFUNC\s0+( n )-1)
.TP
.RI \s-1TF\s0( n )
.RI (\s-1TOPFUNC\s0+( n )-1)
.TP
.RI \s-1BF\s0( n )
.RI (\s-1BOTTOMFUNC\s0+( n )-1)
.PD
.RE
.LP
There are 64 keys reserved for function keys.
The actual positions may not be on left/right/top/bottom of the
keyboard, although they usually are.
.TP
.SM PADKEYS\s0 0x700
This key is a \*(lqnumeric keypad key.\*(rq
These entries should appear only in the
Num Lock translation table; when Num Lock is in effect, these events will be
generated by pressing keys on the right-hand keypad.
The low-order bits indicate which key; the codes for the individual
keys are as follows:
.RS
.br
.ne 7
.TP 20
.SM PADEQUAL\s0 0x700
\*(lq=\*(rq key
.TP 20
.SM PADSLASH\s0 0x701
\*(lq/\*(rq key
.TP 20
.SM PADSTAR\s0 0x702
\*(lq\(**\*(rq key
.TP 20
.SM PADMINUS\s0 0x703
\*(lq-\*(rq key
.TP 20
.SM PADSEP\s0 0x704
\*(lq,\*(rq key
.TP 20
.SM PAD7\s0 0x705
\*(lq7\*(rq key
.TP 20
.SM PAD8\s0 0x706
\*(lq8\*(rq key
.TP 20
.SM PAD9\s0 0x707
\*(lq9\*(rq key
.TP 20
.SM PADPLUS\s0 0x708
\*(lq+\*(rq key
.TP 20
.SM PAD4\s0 0x709
\*(lq4\*(rq key
.TP 20
.SM PAD5\s0 0x70A
\*(lq5\*(rq key
.TP 20
.SM PAD6\s0 0x70B
\*(lq6\*(rq key
.TP 20
.SM PAD1\s0 0x70C
\*(lq1\*(rq key
.TP 20
.SM PAD2\s0 0x70D
\*(lq2\*(rq key
.TP 20
.SM PAD3\s0 0x70E
\*(lq3\*(rq key
.TP 20
.SM PAD0\s0 0x70F
\*(lq0\*(rq key
.TP 20
.SM PADDOT\s0 0x710
\*(lq.\*(rq key
.TP 20
.SM PADENTER\s0 0x711
\*(lqEnter\*(rq key
.RE
.LP
In
.SB TR_ASCII
mode, when a function key is pressed, the following escape
sequence is sent:
.RS
\s-1ESC\s0[0\|.\|.\|.\.\|9z
.RE
where 
.SM ESC
is a single escape character and \*(lq0\|.\|.\.\|9\*(rq
indicates the decimal representation of the function-key value.
For example,
function key
.B R1
sends the sequence:
.RS
\s-1ESC\s0[208z
.RE
because the decimal value of \s-1RF\s0(1) is 208.
In
.SB TR_EVENT
mode, if there is a
.SM VUID
event code for the function key in question, an event with that event code is
generated; otherwise, individual events for the characters of the escape
sequence are generated.
.SS Keyboard Compatibility Mode
.LP
.B kb
is in \*(lqcompatibility mode\*(rq when it starts up.
In this mode, when the
keyboard is in the
.SB TR_EVENT
translation mode,
.SM ISO
8859/1 characters from the \*(lqupper half\*(rq of the character set (that is,
characters with the 8th bit set) are presented as events with codes in the
.SB ISO_FIRST
range (as defined in
.BR <sundev/vuid_event.h> ).
The event code is
.SB ISO_FIRST
plus the character value.
This is for backwards compatibility with older
versions of the keyboard driver.
If compatibility mode is turned off,
.SM ISO
8859/1 characters are presented as events with codes equal to the character
code.
.SH IOCTLS
.IX  "ioctls for keyboards"  "KIOCTRANS"  "\fLioctl\fP's for keyboards"  "\fLKIOCTRANS\fP \(em set keyboard translation"
.IX  "KIOCTRANS set keyboard translation"  ""  "\fLKIOCTRANS\fP \(em set keyboard translation"
.IX  "set keyboard translation ioctl"  ""  "set keyboard translation \fLioctl\fP \(em \fLKIOCTRANS\fP"
.IX  "ioctls for keyboards"  "KIOCGTRANS"  "\fLioctl\fP's for keyboards"  "\fLKIOCGTRANS\fP \(em get keyboard translation"
.IX  "KIOCGTRANS get keyboard translation"  ""  "\fLKIOCGTRANS\fP \(em get keyboard translation"
.IX  "get keyboard translation ioctl"  ""  "get keyboard translation \fLioctl\fP \(em \fLKIOCGTRANS\fP"
.LP
The following
.B ioctl(\|) 
requests set and retrieve the current translation mode of a keyboard:
.TP 15
.SB KIOCTRANS
The argument is a pointer to an
.BR int .
The translation mode is set to the value in the
.B int
pointed to by the argument.
.TP
.SB KIOCGTRANS
The argument is a pointer to an
.BR int .
The current translation mode is stored in the
.B int
pointed to by the argument.
.LP
.B ioctl(\|)
requests
for changing and retrieving entries from the keyboard translation table use
the
.B kiockeymap
structure:
.br
.ne 12
.LP
.RS
.nf
.ft B
struct	kiockeymap {
	int	kio_tablemask;	/* Translation table (one of: 0, \s-1CAPSMASK\s0,
				   \s-1SHIFTMASK\s0, \s-1CTRLMASK\s0, \s-1UPMASK\s0,
				   \s-1ALTGRAPHMASK\s0, \s-1NUMLOCKMASK\s0) */
#define \s-1KIOCABORT\s01	\-1	/* Special \*(lqmask\*(rq: abort1 keystation */
#define \s-1KIOCABORT\s02	\-2	/* Special \*(lqmask\*(rq: abort2 keystation */
	u_char	kio_station;	/* Physical keyboard key station (0-127) */
	u_short	kio_entry;	/* Translation table station's entry */
	char	kio_string[10];	/* Value for \s-1STRING\s0 entries (null terminated) */
};
.fi
.ft R
.RE
.TP 15
.SB KIOCSKEY
.IX  "ioctls for keyboards"  "KIOCSKEY"  "\fLioctl\fP's for keyboards"  "\fLKIOCSKEY\fP \(em change translation table entry"
.IX  "KIOCSKEY change translation table entry"  ""  "\fLKIOCSKEY\fP \(em change translation table entry"
.IX  "change translation table entry ioctl"  ""  "change translation table entry \fLioctl\fP \(em \fLKIOCSKEY\fP"
The argument is a pointer to a
.B kiockeymap
structure.
The translation table entry referred to by the values in that
structure is changed.
.IP
.B kio_tablemask
specifies which of the five translation tables contains the entry to be
modified:
.RS
.RS
.TP 20
.SM UPMASK\s0 0x0080
\*(lqKey Up\*(rq translation table.
.TP
.SM NUMLOCKMASK\s0 0x0800
\*(lqNum Lock\*(rq translation table.
.TP
.SM CTRLMASK\s0 0x0030
\*(lqControlled\*(rq translation table.
.TP
.SM ALTGRAPHMASK\s0 0x0200
\*(lqAlt Graph\*(rq translation table.
.TP
.SM SHIFTMASK\s0 0x000E
\*(lqShifted\*(rq translation table.
.TP
.SM CAPSMASK\s0 0x0001
\*(lqCaps Lock\*(rq translation table.
.TP
(No shift keys pressed or locked)
\*(lqUnshifted\*(rq translation table.
.RE
.RE
.IP
.B kio_station
specifies the keystation code for the entry to be modified.
The value of
.B kio_entry
is stored in the entry in question.
If
.B kio_entry
is between
.SM STRING
and
.SM STRING+15\s0,
the string contained in
.B kio_string
is copied to the appropriate string table entry.
This call may return
.SB \%EINVAL
if there are invalid arguments.
.IP
There are a couple special values of
.B kio_tablemask
that affect
the two step \*(lqbreak to the
.SM PROM
monitor\*(rq sequence.
The usual sequence is
.B SETUP\fR\-\fBa
or
.BR L1\fR\-\fBa .
If
.B kio_tablemask
is
.SB KIOCABORT1
then the value of
.B kio_station
is set to be the first keystation in the sequence.
If
.B kio_tablemask
is
.SB KIOCABORT2
then the value of
.B kio_station
is set to be the second keystation in the sequence.
.TP
.SB KIOCGKEY
.IX  "ioctls for keyboards"  "KIOCGKEY"  "\fLioctl\fP's for keyboards"  "\fLKIOCGKEY\fP \(em get translation table entry"
.IX  "KIOCGKEY get translation table entry"  ""  "\fLKIOCGKEY\fP \(em get translation table entry"
.IX  "get translation table entry ioctl"  ""  "get translation table entry \fLioctl\fP \(em \fLKIOCGKEY\fP"
The argument is a pointer to a
.B kiockeymap
structure.
The current value of the keyboard translation table entry specified
by
.B kio_tablemask
and
.B kio_station
is stored in the structure pointed to by the argument.
This call may return
.SB EINVAL
if there are invalid arguments.
.TP
.SB KIOCTYPE
.IX  "ioctls for keyboards"  "KIOCTYPE"  "\fLioctl\fP's for keyboards"  "\fLKIOCTYPE\fP \(em get keyboard type"
.IX  "KIOCTYPE get keyboard type"  ""  "\fLKIOCTYPE\fP \(em get keyboard type"
.IX  "get keyboard type ioctl"  ""  "get keyboard type \fLioctl\fP \(em \fLKIOCTYPE\fP"
The argument is a pointer to an
.BR int .
A code indicating the type of the keyboard is stored in the
.B int
pointed to by the argument:
.RS
.RS
.PD 0
.TP 15
.SB KB_KLUNK
Micro Switch 103\s-1SD\s032-2
.TP
.B \s-1KB_VT\s0100
Keytronics \s-1VT\s0100 compatible
.TP
.B \s-1KB_SUN\s02
Sun-2 keyboard
.TP
.B \s-1KB_SUN\s03
Sun-3 keyboard
.TP
.B \s-1KB_SUN\s04
Sun-4 keyboard
.TP
.SB KB_ASCII
\s-1ASCII\s0 terminal masquerading as keyboard
.PD
.RE
.RE
.IP
\-1 is stored in the
.B int
pointed to by the argument if the keyboard type is unknown.
.TP
.SB KIOCLAYOUT
.IX  "ioctls for keyboards"  "KIOCLAYOUT"  "\fLioctl\fP's for keyboards"  "\fLKIOCLAYOUT\fP \(em get keyboard type"
.IX  "KIOCLAYOUT get keyboard type"  ""  "\fLKIOCLAYOUT\fP \(em get keyboard type"
.IX  "get keyboard type ioctl"  ""  "get keyboard type \fLioctl\fP \(em \fLKIOCLAYOUT\fP"
The argument is a pointer to an
.BR int .
On a Sun-4 keyboard, the layout code specified by the keyboard's
.SM DIP
switches is stored in the
.B int
pointed to by the argument.
.TP
.SB KIOCCMD
.IX  "ioctls for keyboards"  "KIOCCMD"  "\fLioctl\fP's for keyboards"  "\fLKIOCCMD\fP \(em send a keyboard command"
.IX  "KIOCCMD send a keyboard command"  ""  "\fLKIOCCMD\fP \(em send a keyboard command"
.IX  "send a keyboard command ioctl"  ""  "send a keyboard command \fLioctl\fP \(em \fLKIOCCMD\fP"
.IX  "ioctls for keyboards"  "KIOCSLED"  "\fLioctl\fP's for keyboards"  "\fLKIOCSLED\fP \(em set LEDs"
.IX  "KIOCSLED set LEDs"  ""  "\fLKIOCSLED\fP \(em set LEDs"
.IX  "set LEDs ioctl"  ""  "set LEDs \fLioctl\fP \(em \fLKIOCSLED\fP"
The argument is a pointer to an
.BR int .
The command specified by the value of the
.B int
pointed to by the argument is sent to the keyboard.
The commands that can be
sent are:
.IP
Commands to the Sun-2, Sun-3, and Sun-4 keyboard:
.RS
.RS
.PD 0
.TP 20
.SB KBD_CMD_RESET
Reset keyboard as if power-up.
.TP
.SB KBD_CMD_BELL
Turn on the bell.
.TP
.SB KBD_CMD_NOBELL
Turn off the bell
.PD
.RE
.RE
.IP
Commands to the Sun-3 and Sun-4 keyboard:
.RS
.RS
.PD 0
.TP 20
.SB KBD_CMD_CLICK
Turn on the click annunciator.
.TP
.SB KBD_CMD_NOCLICK
Turn off the click annunciator.
.PD
.RE
.RE
.IP
Inappropriate commands for particular keyboard types are ignored.
Since there is no reliable way to get the state of the bell or click
(because we cannot query the keyboard, and also because a process could
do writes to the appropriate serial driver \(em thus going around this
.B ioctl(\)
request)
we do not provide an equivalent
.B ioctl(\)
to query its state.
.TP
.SB KIOCSLED
The argument is a pointer to an
.BR char .
On the Sun-4 keyboard, the
.SM LED\s0s
are set to the value specified in that
.BR char .
The values for the four
.SM LED\s0s
are:
.RS
.RS
.PD 0
.TP 20
.SB LED_CAPS_LOCK
\*(lqCaps Lock\*(rq light.
.TP 20
.SB LED_COMPOSE
\*(lqCompose\*(rq light.
.TP 20
.SB LED_SCROLL_LOCK
\*(lqScroll Lock\*(rq light.
.TP 20
.SB LED_NUM_LOCK
\*(lqNum Lock\*(rq light.
.PD
.RE
.RE
.TP
.SB KIOCGLED
The argument is a pointer to a
.BR char .
The current state of the
.SM LED\s0s
is stored in the
.B char
pointed to by the argument.
.IX  "ioctls for keyboards"  "KIOCGLED"  "\fLioctl\fP's for keyboards"  "\fLKIOCGLED\fP \(em get LEDs"
.IX  "KIOCGLED get LEDs"  ""  "\fLKIOCGLED\fP \(em get LEDs"
.IX  "get LEDs ioctl"  ""  "get LEDs \fLioctl\fP \(em \fLKIOCGLED\fP"
.TP
.SB KIOCSCOMPAT
.IX  "ioctls for keyboards"  "KIOCSCOMPAT"  "\fLioctl\fP's for keyboards"  "\fLKIOCSCOMPAT\fP \(em set compatibility mode"
.IX  "KIOCSCOMPAT set compatibility mode"  ""  "\fLKIOCSCOMPAT\fP \(em set compatibility mode"
.IX  "set compatibility mode ioctl"  ""  "set compatibility mode \fLioctl\fP \(em \fLKIOCSCOMPAT\fP"
The argument is a pointer to an
.BR int .
\*(lqCompatibility mode\*(rq is turned on if the
.B int
has a value of 1, and is turned off if the
.B int
has a value of 0.
.TP
.SB KIOCGCOMPAT
The argument is a pointer to an
.BR int .
The current state of \*(lqcompatibility mode\*(rq is stored in the
.B int
pointed to by the argument.
.IX  "ioctls for keyboards"  "KIOCGCOMPAT"  "\fLioctl\fP's for keyboards"  "\fLKIOCGCOMPAT\fP \(em get compatibility mode"
.IX  "KIOCGCOMPAT get compatibility mode"  ""  "\fLKIOCGCOMPAT\fP \(em get compatibility mode"
.IX  "get compatibility mode ioctl"  ""  "get compatibility mode \fLioctl\fP \(em \fLKIOCGCOMPAT\fP"
.TP
.SB KIOCGDIRECT
.IX  "ioctls for keyboards"  "KIOCSDIRECT"  "\fLioctl\fP's for keyboards"  "\fLKIOCSDIRECT\fP \(em set keyboard \*(lqdirect input\*(rq state"
.IX  "KIOCSDIRECT set keyboard \*(lqdirect input\*(rq state"  ""  "\fLKIOCSDIRECT\fP \(em set keyboard \*(lqdirect input\*(rq state"
.IX  "set keyboard \*(lqdirect input\*(rq state"  ""  "set keyboard \*(lqdirect input\*(rq state \fLioctl\fP \(em \fLKIOCSDIRECT\fP"
.IX  "ioctls for keyboards"  "KIOCGDIRECT"  "\fLioctl\fP's for keyboards"  "\fLKIOCGDIRECT\fP \(em get keyboard \*(lqdirect input\*(rq state"
.IX  "KIOCGDIRECT get keyboard \*(lqdirect input\*(rq state"  ""  "\fLKIOCGDIRECT\fP \(em get keyboard \*(lqdirect input\*(rq state"
.IX  "get keyboard \*(lqdirect input\*(rq state"  ""  "get keyboard \*(lqdirect input\*(rq state \fLioctl\fP \(em \fLKIOCGDIRECT\fP"
These
.B ioctl(\|)
requests
are supported for compatibility with the system keyboard device
.BR /dev/kbd .
.SB KIOCSDIRECT
has no effect, and
.SB KIOCGDIRECT
always returns 1.
.SH SEE ALSO
.BR click (1),
.BR loadkeys (1),
.BR kbd (4S),
.BR termio (4),
.BR win (4S),
.BR keytables (5)
.LP
.TX SVPG
(describes
.B firm_event
format)
.IX  "kb device"  ""  "\fLkb\fP \(em Sun keyboard"  ""  PAGE END
