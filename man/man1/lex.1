.\" @(#)lex.1 1.1 92/07/30 SMI; from UCB 6.2 4/14/86 and S5R2 6.2 9/2/83
.TH LEX 1 "1 December 1988"
.SH NAME
lex \- lexical analysis program generator
.SH SYNOPSIS
.B lex
[
.B \-fntv
] [
.I filename
] .\|.\|.
.SH DESCRIPTION
.IX  "lex command"  ""  "\fLlex\fP \(em generate lexical analyzer"
.IX  "programming tools"  "lex command"  ""  "\fLlex\fP \(em generate lexical analyzer"
.IX  "programming languages"  "lex command"  ""  "\fLlex\fP \(em generate lexical analyzer"
.IX  "compiler generators" lex ""  "\fLlex\fP \(em lexical analyzer generator"
.IX  languages  "lex command"  ""  "\fLlex\fP \(em generate lexical analyzer"
.IX  generate "lexical analyzer \(em \fLlex\fP"
.LP
.B lex
generates programs to be used in simple lexical analysis of text.
Each
.I filename
(the standard input by default) contains regular expressions
to search for, and actions written in C
to be executed when expressions are found.
.LP
A C
source program,
.B lex.yy.c
is generated, to be compiled as follows:
.IP
.B cc lex.yy.c \-ll
.LP
This program, when run, copies unrecognized portions of
the input to the output, and executes the associated C
action for each regular expression that is recognized.
The actual string matched is left in
.BR yytext ,
an external character array.
.LP
Matching is done in order of the strings in the file.  The strings
may contain square braces to indicate character classes,
as in
.B [abx\-z]
to indicate
.BR a , " b" , " x" ,
.BR y ", and " z ;
and the operators
.BR \(** ", " + " and " ? ,
which mean, respectively,
any nonnegative number, any positive number, or either
zero or one occurrences of the previous character or character-class.
The \*(lqdot\*(rq character
.RB (`\| . \|')
is the class of all
.SM ASCII
characters except
.SM NEWLINE\s0.
.LP
Parentheses for grouping and vertical bar for alternation are
also supported.  The notation
.IB r { d , \|e }
in a rule indicates instances of regular expression
.I r
between
.I d
and
.IR e .
It has a higher precedence than
.BR | ,
but lower than that of
.BR \(** ,
.BR ? ,
.BR + ,
or concatenation.
The
.B \s+2^\s0
(carat character)
at the beginning of an expression permits a
successful match only immediately after a
.SM NEWLINE\s0,
and the
.B $
character at the end of an expression requires a trailing
.SM NEWLINE\s0.
.LP
The
.B /
character in an expression indicates trailing context;
only the part of the expression up to the slash is returned in
.IR yytext ,
although the remainder of the expression must follow in the input
stream.
.LP
An operator character may be used as an ordinary symbol
if it is within `\fB"\fR'
symbols or preceded by
.RB ` \e '.
.LP
Three subroutines defined as macros are expected:
.B input(\|)
to read a character;
.BI unput( c )
to replace a character read; and
.BI output( c )
to place an output character.  They are defined in terms
of the standard streams, but you can override them.
The program generated is named
.BR yylex(\|) ,
and the library contains a
.B main(\|)
which calls it.
The action
.SM REJECT
on the right side of the rule rejects this
match and executes the next suitable match;
the function
.B yymore(\|)
accumulates additional characters
into the same
.BR yytext ;
and the function
.BI yyless( n )
where
.I n
is the number of characters to retain in
.BR yytext.
The macros
.I input
and
.I output
use files
.B yyin
and
.B yyout
to read from and write to,
defaulted to
.B stdin
and
.BR stdout ,
respectively.
.LP
In a
.B lex
program, any line beginning with a blank is assumed to contain only
C text and is copied; if it precedes
.B %%
it is copied into the external definition area of the
.B lex.yy.c
file.
All rules should follow a
.BR %% ,
as in
.SM YACC.
Lines preceding
.B %%
which begin with a nonblank character define
the string on the left to be the remainder of
the line; it can be used later by surrounding it with
.BR {\|} .
Note: curly brackets do not imply parentheses;
only string substitution is done.
.LP
The external names generated by
.B lex
all begin with the prefix
.BR yy " or " \s-1YY\s0 .
.LP
Certain table sizes for the resulting finite-state machine
can be set in the definitions section:
.RS
.TP "@.\s-1TP\s0
.BI %p " n\^"
number of positions is
.I n\^
(default 2000)
.ns
.TP
.BI %n " n\^"
number of states is
.I n\^
(500)
.ns
.TP
.BI %t " n\^"
number of parse tree nodes is
.I n\^
(1000)
.ns
.TP
.BI %a " n\^"
number of transitions is
.I n\^
(3000)
.RE
.LP
The use of one or more of the above automatically implies the
.B \-v
option,
unless the
.B \-n
option is used.
.SH OPTIONS
.TP
.B \-f
Faster compilation. Do not bother to pack
the resulting tables; limited to small programs.
.TP
.B \-n
Opposite of
.BR \-v ;
.B \-n
is default.
.TP
.B \-t
Place the result on the standard output instead of in file
.BR lex.yy.c .
.TP
.B \-v
Print a one-line summary of statistics of the generated analyzer.
.SH EXAMPLES
.LP
The following command line:
.RS
.B lex lexcommands
.RE
.LP
would draw
.B lex
instructions from the file
.BR lexcommands ,
and place the output in
.BR lex.yy.c .
.LP
The following:
.IP
.ft B
%%
[A\-Z]	putchar (yytext[0]+\'a\'\-\'A\');
[ ]+$	;
[ ]+	putchar(\' \');
.ft R
.LP
is an example of a
.B lex
program.
It converts upper case to lower, removes blanks at the end of lines,
and replaces multiple blanks by single blanks.
.LP
.RS
.ta +8n +8n +8n +8n
.ft B
.nf
D	[0\-9]
%%
if	printf("\s-1IF\s+1 statement\\n");
[a\-z]+	printf("tag, value %s\\n",yytext);
0{D}+	printf("octal number %s\\n",yytext);
{D}+	printf("decimal number %s\\n",yytext);
"++"	printf("unary op\\n");
"+"	printf("binary op\\n");
"/\(**"	{	loop:
		while (input(\|) != \(fm\(**\(fm);
		switch (input(\|))
			{
			case \(fm/\(fm: break;
			case \(fm\(**\(fm: unput(\(fm\(**\(fm);
			default: go to loop;
			}
		}
.fi
.ft R
.RE
.SH FILES
.PD 0
.TP 20
.B lex.yy.c
.PD
.SH "SEE ALSO"
.BR sed (1V),
.BR yacc (1)
.LP
.TX PUL
.SH NOTES
The
.B lex
command
is not changed to support 8-bit symbol names,
as this would produce
.B lex
source code
that is not portable between systems.
