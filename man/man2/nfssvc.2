.\" @(#)nfssvc.2 1.1 92/07/30 SMI;
.TH NFSSVC 2 "21 January 1990"
.SH NAME
nfssvc, async_daemon \- NFS daemons
.SH SYNOPSIS
.nf
.B nfssvc (sock)
.B int sock;
.fi
.LP
.BR async_daemon (\|)
.IX  nfssvc()  ""  \fLnfssvc()\fP
.IX  "socket operations"  nfssvc()  ""  \fLnfssvc()\fP
.IX  "network file system daemons"
.IX  daemons  "network file system"
.IX  async_daemon()  ""  \fLasync_daemon()\fP
.IX  "socket operations"  async_daemon()  ""  \fLasync_daemon()\fP
.SH DESCRIPTION
.LP
.B nfssvc(\|)
starts an
.SM NFS
daemon listening on socket
.IR sock .
The socket must be
.BR \s-1AF_INET\s0 ,
and
.SB SOCK_DGRAM
(protocol
.BR \s-1UDP/IP\s0 ).
The system call will return only if the socket is invalid.
.LP
.B async_daemon(\|)
implements the
.SM NFS
daemon that handles asynchronous I/O for an
.SM NFS
client.  This system call never returns.
.LP
Both system calls result in kernel-only processes with user memory discarded.
.SH SEE ALSO
.BR mountd (8C)
.SH BUGS
.LP
There should be a way to dynamically create kernel-only processes
instead of having to make system calls from userland to simulate this.
