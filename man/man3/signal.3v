.\" @(#)signal.3v 1.1 92/07/30 SMI; from UCB 4.3
.\" Copyright (c) 1980 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
.\"
.TH SIGNAL 3V "21 January 1990"
.ie t .ds d \(dg
.el .ds d \z|+
.ie t .ds b \(bu
.el .ds b @
.SH NAME
signal \- simplified software signal facilities
.SH SYNOPSIS
.LP
.nf
.ft B
#include <signal.h>
.ft
.fi
.LP
.nf
.ft B
void (*signal(sig, func))(\|)
void (*func)(\|);
.ft
.fi
.IX  "signal()"  ""  "\fLsignal()\fP \(em software signals"
.IX  "software signal"  ""  "software signal \(em \fLsignal()\fP"
.SH DESCRIPTION
.LP
.B signal(\|)
is a simplified interface to the more general
.BR sigvec (2)
facility.  Programs that use
.B signal(\|)
in preference to
.B sigvec(\|)
are more likely to be portable to all
systems.
.LP
A signal is generated by some abnormal event,
initiated by a user at a terminal
(quit, interrupt, stop),
by a program error (bus error, etc.),
by request of another program (kill),
or when a process is stopped because it wishes to access
its control terminal while in the background (see
.BR termio (4)).
Signals are optionally generated
when a process resumes after being stopped,
when the status of child processes changes,
or when input is ready at the control terminal.
Most signals cause termination of the receiving process if no action
is taken; some signals instead cause the process receiving them
to be stopped, or are simply discarded if the process has not
requested otherwise.
Except for the
.SB SIGKILL
and
.SB SIGSTOP
signals, the
.B signal(\|)
call allows signals either to be ignored
or to interrupt to a specified location.
The following is a list of all signals with
names as in the include file
.BR <signal.h> :
.RS
.LP
.nf
.ta \w'SIGVTALRM 'u +\w'15*  'u
\fB\s-1SIGHUP\s0\fR	1	hangup
\fB\s-1SIGINT\s0\fR	2	interrupt
\fB\s-1SIGQUIT\s0\fR	3*	quit
\fB\s-1SIGILL\s0\fR	4*	illegal instruction
\fB\s-1SIGTRAP\s0\fR	5*	trace trap
\fB\s-1SIGABRT\s0\fR	6*	abort (generated by \fBabort\fP(3) routine)
\fB\s-1SIGEMT\s0\fR	7*	emulator trap
\fB\s-1SIGFPE\s0\fR	8*	arithmetic exception
\fB\s-1SIGKILL\s0\fR	9	kill (cannot be caught, blocked, or ignored)
\fB\s-1SIGBUS\s0\fR	10*	bus error
\fB\s-1SIGSEGV\s0\fR	11*	segmentation violation
\fB\s-1SIGSYS\s0\fR	12*	bad argument to system call
\fB\s-1SIGPIPE\s0\fR	13	write on a pipe or other socket with no one to read it
\fB\s-1SIGALRM\s0\fR	14	alarm clock
\fB\s-1SIGTERM\s0\fR	15	software termination signal
\fB\s-1SIGURG\s0\fR	16\*b	urgent condition present on socket
\fB\s-1SIGSTOP\s0\fR	17\*d	stop (cannot be caught, blocked, or ignored)
\fB\s-1SIGTSTP\s0\fR	18\*d	stop signal generated from keyboard
\fB\s-1SIGCONT\s0\fR	19\*b	continue after stop
\fB\s-1SIGCHLD\s0\fR	20\*b	child status has changed
\fB\s-1SIGTTIN\s0\fR	21\*d	background read attempted from control terminal
\fB\s-1SIGTTOU\s0\fR	22\*d	background write attempted to control terminal
\fB\s-1SIGIO\s0\fR	23\*b	I/O is possible on a descriptor (see \fBfcntl\fR(2V))
\fB\s-1SIGXCPU\s0\fR	24	cpu time limit exceeded (see \c
.BR getrlimit (2))
\fB\s-1SIGXFSZ\s0\fR	25	file size limit exceeded (see \c
.BR getrlimit (2))
\fB\s-1SIGVTALRM\s0\fR	26	virtual time alarm (see \c
.BR getitimer (2))
\fB\s-1SIGPROF\s0\fR	27	profiling timer alarm (see \c
.BR getitimer (2))
\fB\s-1SIGWINCH\s0\fR	28\*b	window changed (see \fBtermio\fR(4) and \fBwin\fR(4S))
\fB\s-1SIGLOST\s0\fR	29*	resource lost (see \c
.BR lockd (8C))
\fB\s-1SIGUSR1\s0\fR	30	user-defined signal 1
\fB\s-1SIGUSR2\s0\fR	31	user-defined signal 2
.fi
.RE
.LP
The starred signals in the list above cause a core image
if not caught or ignored.
.LP
If
.I func
is
.BR \s-1SIG_DFL\s0 ,
the default action for signal
.I sig
is reinstated; this default is termination
(with a core image for starred signals)
except for signals marked with \*b or \*d.
Signals marked with \*b are discarded if the action
is
.BR \s-1SIG_DFL\s0 ;
signals marked with \*d cause the process to stop.
If
.I func
is
.SB SIG_IGN
the signal is subsequently ignored
and pending instances of the signal are discarded.
Otherwise, when the signal occurs
further occurrences of the signal are
automatically blocked and
.I func
is called.
.LP
A return from the function unblocks
the handled signal and
continues the process at the point it was interrupted.
.B
Unlike previous signal facilities, the handler
.I func
.B
remains installed after a signal has been delivered.
.LP
If a caught signal occurs
during certain system calls, 
terminating the call prematurely, the call
is automatically restarted.
In particular this can occur
during a
.BR read (2V)
or
.BR write (2V)
on a slow device (such as a terminal; but not a file)
and during a
.BR wait (2V).
.LP
The value of
.B signal(\|)
is the previous (or initial)
value of
.I func
for the particular signal.
.LP
After a
.BR fork (2V)
or
.BR vfork (2)
the child inherits all signals.  An
.BR execve (2V)
resets all caught signals to the default action;
ignored signals remain ignored.
.SH SYSTEM V DESCRIPTION
.LP
If
.I func
is
.SB SIG_IGN
the signal is subsequently ignored
and pending instances of the signal are discarded.
Otherwise, when the signal occurs,
.I func
is called.
Further occurrences of the signal are not
automatically blocked.
The value of
.I func
for the caught signal is reset to
.SB SIG_DFL
before
.I func
is called, unless the signal is
.SB SIGILL
or
.BR \s-1SIGTRAP\s0 .
.LP
A return from the function
continues the process at the point at which it was interrupted.
The handler
.I func
does not remain installed after a signal has been delivered.
.LP
If a caught signal occurs
during certain system calls, causing
the call to terminate prematurely, the call
is interrupted.
In particular this can occur
during a
.BR read (2V)
or
.BR write (2V)
on a slow device (such as a terminal; but not a file)
and during a
.BR wait (2V).
After the signal catching function returns, the
interrupted system call may return a \-1 to the calling process with
.B errno
set to
.SM EINTR\s0.
.SH RETURN VALUES
.LP
.B signal(\|)
returns
the previous action
on success.
On failure,
it returns
\-1
and sets
.B errno
to indicate the error.
.SH ERRORS
.LP
.B signal(\|)
will fail and no action will take place if one of the
following occurs:
.TP 15
.SM EINVAL
.I sig
was not a valid signal number.
.IP
An attempt was made to ignore or supply a handler for
.SB SIGKILL
or
.BR \s-1SIGSTOP\s0 .
.SH SEE ALSO
.BR kill (1),
.BR execve (2V),
.BR fork (2V),
.BR getitimer (2),
.BR getrlimit (2),
.BR kill (2V),
.BR ptrace (2),
.BR read (2V),
.BR sigblock (2),
.BR sigpause (2V),
.BR sigsetmask (2),
.BR sigstack (2),
.BR sigvec (2),
.BR vfork (2),
.BR wait (2V),
.BR write (2V),
.BR setjmp (3V),
.BR termio (4)
.SH NOTES
.LP
The handler routine can be declared:
.RS
.LP
.nf
.ft B
void handler(sig, code, scp, addr)
int sig, code;
struct sigcontext \(**scp;
char \(**addr;
.ft R
.fi
.RE
.LP
Here
.I sig
is the signal number;
.I code
is a parameter of certain signals that provides additional detail;
.I scp
is a pointer to the
.B sigcontext
structure (defined in
.BR <signal.h> ),
used to restore the context from before the signal;
and
.I addr
is additional address information.
See
.BR sigvec (2)
for more details.
