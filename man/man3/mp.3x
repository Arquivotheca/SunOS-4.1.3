.\" @(#)mp.3x 1.1 92/07/30 SMI; from UCB 4.2
.TH MP 3X "7 September 1989"
.SH NAME
mp, madd, msub, mult, mdiv, mcmp, min, mout, pow, gcd, rpow, itom, xtom, mtox, mfree \- multiple precision integer arithmetic
.SH SYNOPSIS
.ft B
.nf
#include <mp.h>
.sp .5
madd(a, b, c)
\s-1MINT\s0 *a, *b, *c;
.sp .5
msub(a, b, c)
\s-1MINT\s0 *a, *b, *c;
.sp .5
mult(a, b, c)
\s-1MINT\s0 *a, *b, *c;
.sp .5
mdiv(a, b, q, r)
\s-1MINT\s0 *a, *b, *q, *r;
.sp .5
mcmp(a,b)
\s-1MINT\s0 *a, *b;
.sp .5
min(a)
\s-1MINT\s0 *a;
.sp .5
mout(a)
\s-1MINT\s0 *a;
.sp .5
pow(a, b, c, d)
\s-1MINT\s0 *a, *b, *c, *d;
.sp .5
gcd(a, b, c)
\s-1MINT\s0 *a, *b, *c;
.sp .5
rpow(a, n, b)
\s-1MINT\s0 *a, *b;
short n;
.sp .5
msqrt(a, b, r)
\s-1MINT\s0 *a, *b, *r;
.sp .5
sdiv(a, n, q, r)
\s-1MINT\s0 *a, *q;
short n, *r;
.sp .5
\s-1MINT\s0 *itom(n)
short n;
.sp .5
\s-1MINT\s0 *xtom(s)
char *s;
.sp .5
char *mtox(a)
\s-1MINT\s0 *a;
.sp .5
void mfree(a)
\s-1MINT\s0 *a;
.ft R
.fi
.IX  "itom()"  ""  "\fLitom()\fP \(em integer to multiple precision"
.IX  "multiple precision integer arithmetic"  itom()  ""  \fLitom()\fP
.IX  "madd()"  ""  "\fLmadd()\fP \(em multiple precision add"
.IX  "multiple precision integer arithmetic"  madd()  ""  \fLmadd()\fP
.IX  "msub()"  ""  "\fLmsub()\fP \(em multiple precision subtract"
.IX  "multiple precision integer arithmetic"  msub()  ""  \fLmsub()\fP
.IX  "mult()"  ""  "\fLmult()\fP \(em multiple precision multiply"
.IX  "multiple precision integer arithmetic"  mult()  ""  \fLmult()\fP
.IX  "mdiv()"  ""  "\fLmdiv()\fP \(em multiple precision divide"
.IX  "multiple precision integer arithmetic"  mdiv()  ""  \fLmdiv()\fP
.IX  "sdiv()"  ""  "\fLsdiv()\fP \(em multiple precision divide"
.IX  "multiple precision integer arithmetic"  sdiv()  ""  \fLsdiv()\fP
.IX  "min()"  ""  "\fLmin()\fP \(em multiple precision decimal input"
.IX  "multiple precision integer arithmetic"  min()  ""  \fLmin()\fP
.IX  "mout()"  ""  "\fLmout()\fP \(em multiple precision decimal output"
.IX  "multiple precision integer arithmetic"  mout()  ""  \fLmout()\fP
.IX  "pow()"  ""  "\fLpow()\fP \(em multiple precision exponential"
.IX  "multiple precision integer arithmetic"  pow()  ""  \fLpow()\fP
.IX  "gcd()"  ""  "\fLgcd()\fP \(em multiple precision GCD"
.IX  "multiple precision integer arithmetic"  gcd()  ""  \fLgcd()\fP
.IX  "rpow()"   ""  "\fLrpow()\fP \(em multiple precision exponential"
.IX  "multiple precision integer arithmetic"  rpow()  ""  \fLrpow()\fP
.IX  "msqrt()"   ""  "\fLmsqrt()\fP \(em multiple precision exponential"
.IX  "multiple precision integer arithmetic"  msqrt()  ""  \fLmsqrt()\fP
.IX  "xtom()"  ""  "\fLxtom()\fP \(em hexadecimal string to multiple precision"
.IX  "multiple precision integer arithmetic"  xtom()   ""  \fLxtom()\fP
.IX  "mtox()"  ""  "\fLmtox()\fP \(em multiple precision to hexadecimal string"
.IX  "multiple precision integer arithmetic"  mtox()   ""  \fLmtox()\fP
.IX  "mfree()"  ""  "\fLmfree()\fP \(em release multiple precision storage"
.IX  "multiple precision integer arithmetic"  mfree()  ""  \fLmfree()\fP
.SH DESCRIPTION
.LP
These routines perform arithmetic on integers of arbitrary length.
The integers are stored using the defined type
.SM MINT\s0.
Pointers to a
.SM MINT
should be initialized using the function
.BR itom(\|) ,
which sets the initial value to
.IR n .
Alternatively,
.B xtom(\|)
may be used to initialize a
.SM MINT
from a string of hexadecimal digits.
.B mfree(\|)
may be used to release the storage allocated
by the
.B itom(\|) 
and
.B xtom(\|)
routines.
.LP
.BR madd(\|) ,
.B msub(\|)
and
.B mult(\|)
assign to their third arguments the sum,
difference, and product,
respectively, of their first two arguments.
.B mdiv(\|)
assigns the quotient and remainder,
respectively, to its third and fourth
arguments.
.B sdiv(\|)
is like
.B mdiv(\|)
except that the divisor is an ordinary integer.
.B msqrt
produces the square root and remainder of
its first argument.
.B mcmp(\|)
compares the values of its arguments and returns 0
if the two values are equal, a value greater than 0
if the first argument is greater than the second,
and a value less than 0
if the second argument is greater than the first.
.B rpow
raises
.I a
to the
.IR n th
power and assigns this value to
.IR b .
.B pow(\|)
raises
.I a
to the
.IR b th
power, reduces the result modulo
.I c
and assigns this value to
.IR d .
.B min(\|)
and
.B mout(\|)
do decimal input and output.
.B gcd(\|)
finds the greatest common divisor of the first two arguments,
returning it in the third argument.
.B mtox(\|)
provides the inverse of
.BR xtom(\|) .
To release the storage allocated by
.B mtox(\|),
use
.B free(\|)
(see
.BR malloc (3V)).
.LP
Use the
.B \-lmp
loader option to obtain access to these functions.
.SH DIAGNOSTICS
Illegal operations and running out of
memory produce messages and core images.
.SH FILES
.PD 0
.TP 20
.B /usr/lib/libmp.a
.PD
.SH SEE ALSO
.BR malloc (3V)
