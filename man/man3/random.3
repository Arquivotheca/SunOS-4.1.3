.\" Copyright (c) 1983 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
.\"
.\" @(#)random.3 1.1 92/07/30 SMI; from UCB 6.2 9/29/85
.TH RANDOM 3 "6 October 1987"
.SH NAME
random, srandom, initstate, setstate \- better random number generator; routines for changing generators
.SH SYNOPSIS
.B long  random(\|)
.LP
.nf
.B srandom(seed)
.B int  seed;
.fi
.LP
.nf
.B char  *initstate(seed, state, n)
.B unsigned  seed;
.B char  *state;
.B int  n;
.fi
.LP
.nf
.B char  *setstate(state)
.B char  *state;
.fi
.IX  "random()"  ""  "\fLrandom()\fP \(em generate random number"
.IX  "srandom()"  ""  "\fLsrandom()\fP \(em generate random number"
.IX  "initstate()"  ""  "\fLinitstate()\fP \(em random number routines"
.IX  "setstate()"  ""  "\fLsetstate()\fP \(em random number routines"
.IX  "random number generator"  "\fLrandom()\fP"
.IX  "random number generator"  "\fLsrandom()\fP"
.IX  "random number generator"  "\fLinitstate()\fP"
.IX  "random number generator"  "\fLsetstate()\fP"
.IX  "generate random numbers"  "\fLrandom()\fP"
.IX  "generate random numbers"  "\fLsrandom()\fP"
.IX  "generate random numbers"  "\fLinitstate()\fP"
.IX  "generate random numbers"  "\fLsetstate()\fP"
.SH DESCRIPTION
.LP
.B random(\|)
uses a non-linear additive feedback random number generator employing a
default table of size 31 long integers to return successive
pseudo-random numbers in the range from 0 to
.if t 2\u\s-231\s0\d\(mi1.
.if n (2**31)\(mi1.
The period of this random number generator is very large, approximately
.if t 16\(mu(2\u\s-231\s0\d\(mi1).
.if n 16*((2**31)\(mi1).
.LP
.BR random / srandom
have (almost) the same calling sequence and initialization properties as
.BR rand / srand .
The difference is that
.BR rand (3V)
produces a much less random sequence \(em in fact, the low dozen bits
generated by rand go through a cyclic pattern.  All the bits generated by
.B random(\|)
are usable.  For example,
.IP
.B random(\|)&01
.LP
will produce a random binary value.
.LP
Unlike
.BR srand ,
.B srandom(\|)
does not return the old seed; the reason for this is that the amount of
state information used is much more than a single word.  (Two other
routines are provided to deal with restarting/changing random number
generators).  Like
.BR rand (3V),
however,
.B random(\|)
will by default produce a sequence of numbers that can be duplicated by calling
.B srandom(\|)
with
.I 1
as the seed.
.LP
The
.B initstate(\|)
routine allows a state array, passed in as an argument, to be
initialized for future use.  The size of the state array (in bytes) is
used by
.B initstate(\|)
to decide how sophisticated a random number generator it should use \(em
the more state, the better the random numbers will be.  (Current
``optimal'' values for the amount of state information are 8, 32, 64,
128, and 256 bytes; other amounts will be rounded down to the nearest
known amount.  Using less than 8 bytes will cause an error).  The seed
for the initialization (which specifies a starting point for the random
number sequence, and provides for restarting at the same point) is also
an argument.
.B initstate(\|)
returns a pointer to the previous state information array.
.LP
Once a state has been initialized, the
.B setstate(\|)
routine provides for rapid switching between states.
.B setstate(\|)
returns a pointer to the previous state array; its argument state array
is used for further random number generation until the next call to
.B initstate(\|)
or
.BR setstate(\|) .
.LP
Once a state array has been initialized, it may be restarted at a
different point either by calling
.B initstate(\|)
(with the desired seed, the state array, and its size) or by calling both
.B setstate(\|)
(with the state array) and
.B srandom(\|)
(with the desired seed).  The advantage of calling both
.B setstate(\|)
and
.B srandom(\|)
is that the size of the state array does not have to be remembered
after it is initialized.
.LP
With 256 bytes of state information, the period of the random number
generator is greater than
.if t 2\u\s-269\s0\d,
.if n 2**69
which should be sufficient for most purposes.
.SH "SEE ALSO"
.BR rand (3V)
.br
.ne 10
.SH EXAMPLES
.RS
.nf
.ft B
/* Initialize and array and pass it in to initstate. */
.sp .5
static long state1[32] = {
	3,
	0x9a319039, 0x32d9c024, 0x9b663182, 0x5da1f342,
	0x7449e56b, 0xbeb1dbb0, 0xab5c5918, 0x946554fd,
	0x8c2e680f, 0xeb3d799f, 0xb11ee0b7, 0x2d436b86,
	0xda672e2a, 0x1588ca88, 0xe369735d, 0x904f35f7,
	0xd7158fd6, 0x6fa6f051, 0x616e6b96, 0xac94efdc,
	0xde3b81e0, 0xdf0a6fb5, 0xf103bc02, 0x48f340fb,
	0x36413f93, 0xc622c298, 0xf5a42ab8, 0x8a88d77b,
	0xf5ad9d0e, 0x8999220b, 0x27fb47b9
	};
.sp .5
main()
{
	unsigned seed;
	int n;
.sp .5
	seed = 1; 
	n = 128;
	initstate(seed, (char *) state1, n);
.sp .5
	setstate(state1);
	printf("%d\en",random());
}
.ft R
.RE
.fi
.SH DIAGNOSTICS
If
.B initstate(\|)
is called with less than 8 bytes of state information, or if
.B setstate(\|)
detects that the state information has been garbled, error messages are
printed on the standard error output.
.SH WARNINGS
.LP
.B initstate(\|)
casts
.I state
to
.BR "(long *)" ,
so
.I state
must be long-aligned.  If
it is not long-aligned, on some architectures the program will dump core.
.SH BUGS
.LP
.B random(\|)
is only 2/3 as fast as
.BR rand (3V).
