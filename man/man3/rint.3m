.\" @(#)rint.3m 1.1 92/07/30 SMI; from UCB 4.3 BSD
.TH RINT 3M  "15 October 1987"
.SH NAME
aint, anint, ceil, floor, rint, irint, nint \- round to integral value in floating-point or integer format
.SH SYNOPSIS
.LP
.B #include <math.h>
.LP
.nf
.B double aint(x)
.B double x;
.fi
.LP
.nf
.B double anint(x)
.B double x;
.fi
.LP
.nf
.B double ceil(x)
.B double x;
.fi
.LP
.nf
.B double floor(x)
.B double x;
.fi
.LP
.nf
.B double rint(x)
.B double x;
.fi
.LP
.nf
.B int irint(x)
.B double x;
.fi
.LP
.nf
.B int nint(x)
.B double x;
.fi
.SH DESCRIPTION
.IX  "aint()"  ""  "\fLaint()\fP \(em convert to integral floating"
.IX  "mathematical functions"  aint()  ""  "\fLaint()\fP \(em convert to integral floating"
.IX  "anint()"  ""  "\fLanint()\fP \(em anint \(em convert to integral floating"
.IX  "mathematical functions"  anint()  ""  "\fLanint()\fP \(em convert to integral floating"
.IX  "ceil()"  ""  "\fLceil()\fP \(em ceiling \(em convert to integral floating"
.IX  "mathematical functions"  ceil()  ""  "\fLceil()\fP \(em convert to integral floating"
.IX  "floot()"  ""  "\fLfloor()\fP \(em floor \(em convert to integral floating"
.IX  "mathematical functions"  floor()  ""  "\fLfloor()\fP \(em convert to integral floating"
.IX  "rint()"  ""  "\fLrint()\fP \(em rint \(em convert to integral floating"
.IX  "mathematical functions"  rint()  ""  "\fLrint()\fP \(em convert to integral floating"
.IX  "irint()"  ""  "\fLirint()\fP \(em convert to integral floating"
.IX  "mathematical functions"  irint()  ""  "\fLirint()\fP \(em convert to integer"
.IX  "nint()"  ""  "\fLnint()\fP \(em nint() \(em convert to integral floating"
.IX  "mathematical functions"  nint()  ""  "\fLnint()\fP \(em convert to integer"
.LP
.BR aint(\|) , 
.BR anint(\|) , 
.BR ceil(\|) ,
.BR floor(\|) ,
and
.B rint(\|)
convert a double value into an integral value in double
format.  They vary in how they choose the
result when the argument is not already
an integral value.  Here an \*(lqintegral value\*(rq
means a value of a mathematical integer, which
however might be too large to fit in a particular
computer's int format.  All sufficiently large values
in a particular floating-point format are
already integral; in
.SM IEEE
double-precision format, that means all values >= 2**52.
Zeros, infinities, and quiet NaNs are treated
as integral values by these functions,
which always preserve their argument's sign.
.LP
.B aint(\|)
returns the integral value between
.I x
and 0, nearest
.IR x .
This corresponds to
.SM IEEE
rounding toward zero and to the Fortran
generic intrinsic function
.BR aint(\|) .
.LP
.B anint(\|)
returns the nearest integral value to
.IR x ,
except halfway cases are rounded to the
integral value larger in magnitude.
This corresponds to the Fortran generic
intrinsic function
.BR anint(\|) .
.LP
.B ceil(\|)
returns the least integral value greater than or equal to
.IR x .
This corresponds to
.SM IEEE
rounding toward positive infinity.
.LP
.B floor(\|)
returns the greatest integral value less than or equal to
.IR x .
This corresponds to
.SM IEEE
rounding toward negative infinity.
.LP
.B rint(\|)
rounds
.I x
to an integral value according to the current
.SM IEEE
rounding direction.
.LP
.B irint(\|)
converts
.I x
into int format according to the current
.SM IEEE
rounding direction.
.LP
.B nint(\|)
converts
.I x
into int format rounding to the nearest int value, except
halfway cases are rounded to the int value
larger in magnitude.  This corresponds to the
Fortran generic intrinsic function
.BR nint(\|) .
